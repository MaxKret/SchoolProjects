# -*- coding: utf-8 -*-
"""Network-Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/120AOHHbB4_LT_DMc1HiYe4GQmsOxiCX7

# Network Analysis Lab

## Group: 21

### Members: Max Kretschmer and Kara Adamcik


When we are interested in the interactions among entities of interest and the structures that emerge from their relations, we can model the entities and their relations as a graph, which is sufficiently defined by its nodes and edges. Considering a network as a graph allows us to study the overall connectivity of the contained nodes, identify formation of clusters, or position particular nodes in their neighborhood. In this tutorial, we will get started with network analysis. But please note: this is just a start. Network analysis is becoming its own network science.

## ðŸ›’ 1. Prepare

First, we will need to assemble our tools: Apart from Altair, we will use [NetworkX](https://networkx.github.io), a powerful network-analysis library. As a bridge between Altair and NetworkX, we are using [nx_altair](https://github.com/Zsailer/nx_altair). 

You will have to install `nx_altair` and maybe also `networkx` via `!pip install`, which the notebook actually executes as a shell command (note the preceding exclamation mark). SoÂ let's get this out of the way first, after which we import all the libraries we will be using in this notebook:
"""

!pip install networkx nx_altair

import altair as alt
import networkx as nx
import nx_altair as nxa
import pandas as pd

"""### Generate a random graph

To get started quickly, we can create a random graph. The `fast_gnp_random_graph` method uses the ErdÅ‘s-RÃ©nyi model to generate a graph according to two main parameters: the number of nodes **`n`** and the probability that a given pair of nodes is connected **`p`**:
"""

G = nx.fast_gnp_random_graph(n=36, p=.2)

# show graph with nx_altair
nxa.draw_networkx(G)

"""ðŸ’¡ *Play with the parameters of `fast_gnp_random_graph`, but go easy on the `n` *

### Create a network from scratch

You can also create a graph by manually adding nodes and edges with the respective methods `add_edge` and `add_node`:
"""

G = nx.Graph()

G.add_node("Ada")
G.add_node("Bob")
G.add_node("Cai")
G.add_node("Don")
G.add_node("Eva")

G.add_edge("Ada", "Bob")
G.add_edge("Ada", "Cai")
G.add_edge("Ada", "Eva")
G.add_edge("Bob", "Cai")
G.add_edge("Bob", "Don")
G.add_edge("Cai", "Don")

nxa.draw_networkx(G)

"""Note that you actually do not need to add a node, if it is part of an edge. 

ðŸ’¡ *Comment out or remove the `add_node()` statements above (lines 3-7) and check the result!*

An even more compact way of creating a graph, adding nodes, and edges is by simply passing a list of edge tuples when creating the graph:
"""

G = nx.Graph([("Ada", "Bob"),
              ("Ada", "Cai"),
              ("Ada", "Eva"),
              ("Bob", "Cai"),
              ("Bob", "Don"),
              ("Cai", "Don")])

"""### Add attributes to nodes and edges

You can attach attributes to nodes and edges, either when adding them to the graph or later:

"""

G = nx.Graph()

G.add_node(1, time='3pm')
G.nodes[1]

G.nodes[1]['room'] = 5842
G.nodes.data()

"""Here the nodes are defined as numbers, but as we have seen above NetworkX can also take strings as ids

In addition, you can add attributes to edges. A common way to distinguish between different strengths of connections is to assign weights to edges:
"""

G.add_edge(1, 2, weight=4.7)

"""You can also add or edit edge attributes later:"""

G.edges[1, 2]['weight'] = 3.2
G.edges.data()

"""### Load a network dataset 

Network data can come in many formats, and thankfully NetworkX can read and write many of them, including [GEXF](https://networkx.github.io/documentation/stable/reference/readwrite/gexf.html), [GML](https://networkx.github.io/documentation/stable/reference/readwrite/gml.html), [GraphML](https://networkx.github.io/documentation/stable/reference/readwrite/graphml.html) and [JSON](https://networkx.github.io/documentation/stable/reference/readwrite/json_graph.html) (as used by D3.js). 

The co-occurrence network of characters in the novel *Les MisÃ©rables* (1862) by Victor Hugo serves as a common example dataset for network visualization. Let's load and import it. NetworkX does not (yet) load and parse JSON transparently (as Pandas does so elegantly). Therefore, we need to include the package `json` to get this done:

"""

import json

# with open('https://gist.githubusercontent.com/TieJean/bfad558a88b11246884a56d86738b52b/raw/57f21d740bf61012e414b910f349907be00a9667/miserables.json') as f:
#     les_mis = json.load(f)
import requests
request = requests.get('https://gist.githubusercontent.com/TieJean/bfad558a88b11246884a56d86738b52b/raw/57f21d740bf61012e414b910f349907be00a9667/miserables.json')
les_mis = request.json()

# we specify that the dataset is not a multigraph, there are no self-loops
# or multiedges, multiple edges between nodes
G = nx.readwrite.json_graph.node_link_graph(les_mis, multigraph=False)

nxa.draw_networkx(G, node_tooltip="name")

"""## ðŸ•¸ 2. Process

Once we have a graph representation of a network, we can carry out a range of processing steps, for example, to count its elements and generate some graph-theoretical metrics.

### Counting nodes and edges

For a start, we can get the number of nodes and edges:
"""

G.number_of_nodes()

G.number_of_edges()

"""There is a convenient **`info()`** function (akin to the Pandas function of the same name) it gives us some basic stats, including the average degree, i.e., the number of connections an average node in this graph has:"""

print(nx.info(G))

"""### Graph metrics

Networks may vary a lot by their number of edges in relationship to the number of nodes, which is considered the **`density()`** of a network. The density of a network ranges between 0 and 1: from no connections whatsover to all every node is connected to every other node. It thus also relates to the probability of two random nodes being connected, which we have used further above!
"""

density = nx.density(G)
print("Network density:", density)

"""Another metric that interests network scientists is the shortest path between a given pair of nodes, i.e., we might want to know the shortest connection between two characters in the les mis network:"""

names = ("Napoleon", "Jondrette")

ids = [x for x,y in G.nodes(data=True) if y['name'] in names]
ids

path = nx.shortest_path(G, source=ids[0], target=ids[1])

print("Shortest path between {} & {}:".format(names[0], names[1]), path)

"""ðŸ’¡ *Of course, these are just their nondescript ids. What would it take to know their names?*"""

names = [ G.nodes[id]["name"] for id in path ]
names

"""The length of above path equals the edges between these nodes, which equals the number of elements in the list minus 1:"""

print("Length of above path:", len(path)-1)

"""### Measures of centrality

A considerable part of network analysis is devoted to identifying the most important actors in a network according to their position in the network, which is also referred to as centrality. One very simple centrality measure for relative importance of a node is its **degree**, i.e., the number of connections it has to other nodes. NetworkX can calculate this measure for all nodes of the graph in a snap:
"""

degrees = dict(G.degree(G.nodes()))

# save the degrees as a node attribute
nx.set_node_attributes(G, degrees, 'degree')

# check what has been saved
G.nodes.data()

"""We save the node degrees with the respective nodes in the graph, so we can revisit it, when we visualize the graph. But let us do a little â€˜connectivity contestâ€™. *Who are the characters with the most encounters with other characters?*"""

# reverse sort of the degrees
sorted_degree = sorted(degrees.items(), key=lambda x: x[1], reverse=True)
# above x[1] refers to degree as items() returns both keys and values in tuples

print("Top 10 nodes by degree:\n")

for d in sorted_degree[:10]:
  print( " - {} has {} neighbors".format(G.nodes[d[0]]["name"], d[1]) )

"""Node degree only takes into account the immediate neighbors. Another metric for relative importance of a node in a network is **betweenness centrality**, which takes into account all the shortest paths (see above) between all possible node pairs that go pass the respective node. This already indicates that this centrality measure is much more related to the overall importance of each node to the entire network, not just the immediate neighbors."""

between = nx.betweenness_centrality(G)

nx.set_node_attributes(G, between, 'between')

sorted_between = sorted(between.items(), key=lambda x: x[1], reverse=True)

print("Top 10 nodes by between:\n")

for d in sorted_between[:10]:
  print( " - {}: {} ".format(G.nodes[d[0]]["name"], d[1]) )

"""Betweenness centrality also ranges between 0 and 1, where 0 means that no shortest paths and 1 all shortest paths go through this node. Notice how the selection and order of characters actually differ considerably!

## ðŸ¥— 3. Present

After adding several centrality measures, we now have a fertile ground to generate insightful network visualizations that go beyond the default encoding you have already seen above. For the following steps we will continue with the Les MisÃ©rables network.

### Force-directed layouts

Let's generate a network visualization and add a few quick customizations that might help to make sense of the network. First let's give the chart a bit more breathing room via the `properties()` call and add `tooltips` to the nodes:
"""

nxa.draw_networkx(G, node_tooltip='name').properties(width=500, height=500)

"""The `spring_layout` is the default layout; it is an implementation of the Fruchterman-Reingold algorithm and takes several parameters. You can adjust it by generating the `pos` by hand.

ðŸ’¡ *Have a look into the [documentation](https://networkx.github.io/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html?highlight=spring_layout#networkx.drawing.layout.spring_layout)*
"""

pos = nx.spring_layout(G, iterations=100)

nxa.draw_networkx(G, pos, node_tooltip='name').properties(width=500, height=500)

"""### Custom graph layouts

Since nx_altair generates the network visualization as Altair charts, we can actually decide much more about the visual encoding. The first choice is how the visual variable x/y-position is used. In other words, how should the layout of the network be generated. The `spring_layout` is the default graph layout that nx_altair uses, but NetworkX provides several other [graph layouts](https://networkx.github.io/documentation/stable/reference/drawing.html#module-networkx.drawing.layout).

### Customizing visual encodings

In addition, to the node positions the other visual variables can also be changed to reflect design choices and the network data. Let's start with `node_size` and `node_color`:
"""

nxa.draw_networkx(G, pos=pos,
    node_size='degree:Q',
    node_color='group:N',
    cmap = "category10", # pass colormap that is used
    node_tooltip='name:N',
    linewidths=0, # remove borders from circles
).properties(width=500, height=500)

"""### Multi-view visualization

Last but not least, we can harness the interactive powers of Altair to combine the force-directed layout with other visualizations that operate on node or edge data. In the following, we combine a regular force-directed layout with a barchart representing node groups. Selections in one view have impact on the respective other.
"""

# rectangular selection in the network view
selection = alt.selection_interval(encodings=['x', 'y'])

# group selection in the bar chart
selection2 = alt.selection(type="multi", fields=['group'])


# first we create the force-directed layout
chart = nxa.draw_networkx( G, pos=pos,
    node_size=100,
    node_color='group:N',
    width='value:Q',
    node_tooltip='name',
    linewidths=0
)

# get node and edge layers from chart
edges = chart.layer[0]
nodes = chart.layer[1]

# group numbers (needed to keep bar chart stable during selections)
groups = list(range(1,10))

# separate color definition used across both charts
color = alt.Color('group:N', scale=alt.Scale(domain=groups), legend=None)

# adjust node opacity and fill color according to selections
nodes = nodes.encode(
    opacity=alt.condition(selection, alt.value(1), alt.value(0.25)),
    fill=alt.condition(selection2, color, alt.value('lightgray')),
).add_selection(selection,selection2)

# interactive bar chart 
bars = alt.Chart(nodes.data).mark_bar().encode(
    x=alt.X('count()', scale=alt.Scale(domain=(0,20))),
    y = alt.Y('group:O', scale=alt.Scale(domain=(groups))),
    color=color,
    opacity=alt.condition(selection2, alt.value(1), alt.value(0.25)),
).transform_filter(selection).add_selection(selection2)

# concatenate all layers into one multi-view layout
alt.vconcat(edges+nodes, bars)

"""## Your Turn

  1. Add [eigenvector centrality](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html#networkx.algorithms.centrality.eigenvector_centrality) to the node atttributes. Print out the top ten characters based on this centraility measure. 
  2. Draw the graph using the `shell_layout` and the nodes having the same color and shape.  Mouseover will give the name. 
  3. Draw the graph using the `shell_layout` and add encoding `node_size` according to eigenvector centrality and color according to the group. Mouseover will give the name. 
"""

nxa.draw_networkx(G, node_tooltip='name').properties(width=500, height=500)

# 1
eigen = nx.eigenvector_centrality(G)
nx.set_node_attributes(G, eigen, 'centrality')

sorted_eigen = sorted(eigen.items(), key=lambda x: x[1], reverse=True)

print("Top 10 nodes by eigen:")

for d in sorted_eigen[:10]:
  print( " - {}: {} ".format(G.nodes[d[0]]["name"], d[1]) )

# 2
pos = nx.shell_layout(G)

chart = nxa.draw_networkx(
    G, pos=pos, node_tooltip='name'
).properties(width=500, height=500)

chart1 = nxa.draw_networkx( G, pos=pos,
    node_size= 200,
    node_color='group:N',
    width='value:Q',
    node_tooltip='name',
    linewidths=0
)

chart

# 3
chart = nxa.draw_networkx(
    G, pos=pos, node_tooltip='name', node_color='group:N', cmap="category10", node_size='centrality'
).properties(width=500, height=500)

chart

"""## Sources


Tutorials & Documentation
- [Tutorial â€” NetworkX 2.4 documentation](https://networkx.github.io/documentation/stable/tutorial.html)
- [Exploring and Analyzing Network Data with Python](https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python)
- https://github.com/Zsailer/nx_altair

"""